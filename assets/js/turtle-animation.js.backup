/**
 * Happy Turtle Processing - 3D Walking Turtle Animation
 * Three.js Implementation for Hero Section - Enhanced Underwater Scene
 */

(function() {
    'use strict';

    // Wait for DOM and Three.js to load
    function initTurtleAnimation() {
        // Check if Three.js is loaded
        if (typeof THREE === 'undefined') {
            console.error('Three.js not loaded. Turtle animation cannot initialize.');
            showFallbackImage();
            return;
        }

        // Check WebGL support
        if (!isWebGLAvailable()) {
            console.warn('WebGL not supported. Showing fallback image.');
            showFallbackImage();
            return;
        }

        const container = document.getElementById('turtle-hero-canvas');
        if (!container) {
            console.error('Turtle canvas container not found.');
            return;
        }

        // Scene setup
        let scene, camera, renderer, mixer, clock, turtle, animationId, ground;
        let currentAction = null;
        let turtleSwimSpeed = 0.2; // Speed of continuous swimming across screen
        let bubbles = [];
        let seaweeds = [];
        let fish = [];
        let particles = [];
        let coral = [];
        let rocks = [];
        let godRays = [];
        let causticsTime = 0;

        // Initialize the scene
        function init() {
            try {
                // Create scene
                scene = new THREE.Scene();
                // Ocean blue gradient background
                scene.background = new THREE.Color(0x1e8cb5); // Ocean blue
                scene.fog = new THREE.Fog(0x1e8cb5, 1, 10); // Underwater fog effect

                // Clock for animation
                clock = new THREE.Clock();

                // Camera setup
                const width = container.clientWidth;
                const height = container.clientHeight;
                camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
                camera.position.set(0, 1.2, 3.5);
                camera.lookAt(0, 0.8, 0);

                // Renderer setup
                renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true,
                    powerPreference: 'high-performance'
                });
                renderer.setSize(width, height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.outputEncoding = THREE.sRGBEncoding;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.2;

                container.appendChild(renderer.domElement);

                // Underwater lighting - blue/cyan tones
                // Ambient light - soft aqua underwater glow
                const ambientLight = new THREE.AmbientLight(0x4db8d8, 0.7);
                scene.add(ambientLight);

                // Directional light - sunlight filtering through water
                const directionalLight = new THREE.DirectionalLight(0xa8d5e2, 1.0);
                directionalLight.position.set(5, 10, 7);
                directionalLight.castShadow = true;
                directionalLight.shadow.camera.near = 0.1;
                directionalLight.shadow.camera.far = 50;
                directionalLight.shadow.camera.left = -5;
                directionalLight.shadow.camera.right = 5;
                directionalLight.shadow.camera.top = 5;
                directionalLight.shadow.camera.bottom = -5;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                scene.add(directionalLight);

                // Point light - deep ocean blue accent
                const pointLight = new THREE.PointLight(0x1e8cb5, 0.6, 20);
                pointLight.position.set(-3, 3, 3);
                scene.add(pointLight);

                // Fill light - cyan underwater glow
                const fillLight = new THREE.PointLight(0x4dd0e1, 0.4, 15);
                fillLight.position.set(3, 2, -2);
                scene.add(fillLight);

                // Sandy ocean floor with caustics
                const groundGeometry = new THREE.CircleGeometry(3, 64);
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: 0xc2b280, // Sandy beige
                    roughness: 0.9,
                    metalness: 0.1
                });
                ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = 0;
                ground.receiveShadow = true;
                scene.add(ground);

                // Create underwater environment
                createGodRays();
                createBubbles();
                createSeaweed();
                createCoral();
                createRocks();
                createFish();
                createFloatingParticles();

                // Load the turtle model
                loadTurtleModel();

                // Handle window resize
                window.addEventListener('resize', onWindowResize, false);

                // Start animation loop
                animate();

                console.log('Enhanced turtle animation initialized successfully');

            } catch (error) {
                console.error('Error initializing turtle animation:', error);
                showFallbackImage();
            }
        }

        // Create god rays (volumetric light beams)
        function createGodRays() {
            const rayGeometry = new THREE.ConeGeometry(0.3, 4, 8, 1, true);
            const rayMaterial = new THREE.MeshBasicMaterial({
                color: 0xa8d5e2,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide
            });

            for (let i = 0; i < 5; i++) {
                const ray = new THREE.Mesh(rayGeometry, rayMaterial);
                ray.position.set(
                    (Math.random() - 0.5) * 4,
                    3,
                    (Math.random() - 0.5) * 3
                );
                ray.rotation.x = Math.PI;
                ray.userData.offsetX = Math.random() * Math.PI * 2;
                ray.userData.offsetZ = Math.random() * Math.PI * 2;
                godRays.push(ray);
                scene.add(ray);
            }
        }

        // Enhanced bubbles with variety
        function createBubbles() {
            for (let i = 0; i < 25; i++) {
                const size = 0.02 + Math.random() * 0.04; // Varying sizes
                const bubbleGeometry = new THREE.SphereGeometry(size, 8, 8);
                const bubbleMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.4 + Math.random() * 0.3, // Varying opacity
                    shininess: 100
                });

                const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
                bubble.position.set(
                    Math.random() * 5 - 2.5,
                    Math.random() * 2.5,
                    Math.random() * 3 - 1.5
                );
                bubble.userData.speed = 0.08 + Math.random() * 0.25;
                bubble.userData.wobble = Math.random() * Math.PI * 2;
                bubble.userData.wobbleSpeed = 0.5 + Math.random() * 1.5;
                bubbles.push(bubble);
                scene.add(bubble);
            }
        }

        // Enhanced seaweed with bioluminescence
        function createSeaweed() {
            for (let i = 0; i < 10; i++) {
                const height = 0.3 + Math.random() * 0.5;
                const seaweedGeometry = new THREE.CylinderGeometry(0.015, 0.025, height, 8);

                // Some seaweed glows
                const glowing = Math.random() > 0.6;
                const seaweedMaterial = new THREE.MeshStandardMaterial({
                    color: glowing ? 0x4dd0e1 : 0x2d5016,
                    roughness: 0.8,
                    emissive: glowing ? 0x1e8cb5 : 0x000000,
                    emissiveIntensity: glowing ? 0.3 : 0
                });

                const seaweed = new THREE.Mesh(seaweedGeometry, seaweedMaterial);

                const angle = (i / 10) * Math.PI * 2;
                const radius = 1.3 + Math.random() * 0.7;
                seaweed.position.set(
                    Math.cos(angle) * radius,
                    height / 2,
                    Math.sin(angle) * radius
                );
                seaweed.userData.baseRotation = 0.2 + Math.random() * 0.3;
                seaweed.userData.swaySpeed = 0.4 + Math.random() * 0.6;
                seaweed.userData.glowing = glowing;
                seaweeds.push(seaweed);
                scene.add(seaweed);
            }
        }

        // Create coral formations
        function createCoral() {
            const coralColors = [0xff6b9d, 0xffa07a, 0xff8c42, 0xb565d8];

            for (let i = 0; i < 8; i++) {
                const coralGeometry = new THREE.SphereGeometry(0.08 + Math.random() * 0.1, 8, 8);
                const coralMaterial = new THREE.MeshStandardMaterial({
                    color: coralColors[Math.floor(Math.random() * coralColors.length)],
                    roughness: 0.9,
                    metalness: 0.1
                });

                const coralPiece = new THREE.Mesh(coralGeometry, coralMaterial);
                const angle = (i / 8) * Math.PI * 2 + Math.random() * 0.5;
                const radius = 1.0 + Math.random() * 0.8;
                coralPiece.position.set(
                    Math.cos(angle) * radius,
                    0.05,
                    Math.sin(angle) * radius
                );
                coralPiece.scale.y = 0.6 + Math.random() * 0.6;
                coral.push(coralPiece);
                scene.add(coralPiece);
            }
        }

        // Create rocks
        function createRocks() {
            for (let i = 0; i < 6; i++) {
                const rockGeometry = new THREE.DodecahedronGeometry(0.1 + Math.random() * 0.15, 0);
                const rockMaterial = new THREE.MeshStandardMaterial({
                    color: 0x808080,
                    roughness: 1.0,
                    metalness: 0
                });

                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                // Position rocks to avoid turtle's swimming path (z near 0)
                // Place rocks in top and bottom halves, leaving center clear
                const angle = (i / 6) * Math.PI * 2 + Math.random();
                const radius = 0.8 + Math.random() * 1.0;
                const x = Math.cos(angle) * radius;
                let z = Math.sin(angle) * radius;

                // Push rocks away from z=0 to clear turtle's path
                if (Math.abs(z) < 0.4) {
                    z = z > 0 ? 0.6 : -0.6;
                }

                rock.position.set(x, 0.05, z);
                rock.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                rock.castShadow = true;
                rock.receiveShadow = true;
                rocks.push(rock);
                scene.add(rock);
            }
        }

        // Create swimming fish
        function createFish() {
            for (let i = 0; i < 10; i++) {
                // Create simple fish shape
                const fishGroup = new THREE.Group();

                // Body
                const bodyGeometry = new THREE.CylinderGeometry(0.02, 0.03, 0.12, 8);
                const fishColor = Math.random() > 0.5 ? 0xffa500 : 0xff6347;
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: fishColor,
                    roughness: 0.6,
                    metalness: 0.3
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                fishGroup.add(body);

                // Tail
                const tailGeometry = new THREE.ConeGeometry(0.03, 0.06, 4);
                const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
                tail.rotation.z = -Math.PI / 2;
                tail.position.x = -0.08;
                fishGroup.add(tail);

                // Position fish
                const angle = (i / 10) * Math.PI * 2;
                const radius = 1.5 + Math.random() * 0.5;
                fishGroup.position.set(
                    Math.cos(angle) * radius,
                    0.5 + Math.random() * 1.0,
                    Math.sin(angle) * radius
                );

                fishGroup.userData.angle = angle;
                fishGroup.userData.radius = radius;
                fishGroup.userData.speed = 0.3 + Math.random() * 0.4;
                fishGroup.userData.verticalSpeed = 0.1 + Math.random() * 0.2;
                fishGroup.userData.verticalOffset = Math.random() * Math.PI * 2;

                fish.push(fishGroup);
                scene.add(fishGroup);
            }
        }

        // Create floating particles (sediment/plankton)
        function createFloatingParticles() {
            const particleGeometry = new THREE.SphereGeometry(0.005, 4, 4);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.3
            });

            for (let i = 0; i < 40; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(
                    (Math.random() - 0.5) * 6,
                    Math.random() * 3,
                    (Math.random() - 0.5) * 4
                );
                particle.userData.driftX = (Math.random() - 0.5) * 0.02;
                particle.userData.driftY = (Math.random() - 0.5) * 0.01;
                particle.userData.driftZ = (Math.random() - 0.5) * 0.02;
                particles.push(particle);
                scene.add(particle);
            }
        }

        // Load the GLB model
        function loadTurtleModel() {
            const loader = new THREE.GLTFLoader();
            const modelPath = htbData.themeUrl + '/assets/models/turtle.glb';

            console.log('Loading turtle model from:', modelPath);

            loader.load(
                modelPath,
                function(gltf) {
                    turtle = gltf.scene;

                    // Get bounding box to understand size
                    const box = new THREE.Box3().setFromObject(turtle);
                    const size = box.getSize(new THREE.Vector3());

                    // Model is MICROSCOPIC - scale up
                    const desiredHeight = 0.0078125;
                    const scale = desiredHeight / size.y;

                    turtle.scale.set(scale, scale, scale);

                    // Recalculate bounding box after scaling for correct ground offset
                    const scaledBox = new THREE.Box3().setFromObject(turtle);
                    const groundOffset = -scaledBox.min.y;

                    // Position - start off-screen left on the ground, path cleared of rocks
                    turtle.position.set(-3, groundOffset, 0);
                    turtle.rotation.y = Math.PI / 2;

                    // Remove loading class
                    container.classList.remove('loading');

                    // Enable shadows
                    turtle.traverse(function(node) {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                            if (node.material) {
                                node.material.needsUpdate = true;
                            }
                        }
                    });

                    scene.add(turtle);

                    // Setup animation mixer
                    if (gltf.animations && gltf.animations.length > 0) {
                        mixer = new THREE.AnimationMixer(turtle);
                        const walkAnimation = gltf.animations.find(clip =>
                            clip.name.toLowerCase().includes('walk') ||
                            clip.name.toLowerCase().includes('animation')
                        ) || gltf.animations[0];

                        if (walkAnimation) {
                            currentAction = mixer.clipAction(walkAnimation);
                            currentAction.setLoop(THREE.LoopRepeat);
                            currentAction.play();
                        }
                    }

                    console.log('Turtle model loaded successfully');
                },
                function(xhr) {
                    const percentComplete = (xhr.loaded / xhr.total) * 100;
                    console.log('Loading turtle model: ' + Math.round(percentComplete) + '%');
                },
                function(error) {
                    console.error('Error loading turtle model:', error);
                    showFallbackImage();
                }
            );
        }

        // Animation loop
        function animate() {
            animationId = requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Camera sway - subtle underwater current effect
            camera.position.x += Math.sin(time * 0.3) * 0.0003;
            camera.position.y += Math.cos(time * 0.2) * 0.0002;
            camera.lookAt(0, 0.8, 0);

            // Animate caustics on ocean floor (simulated)
            causticsTime += delta * 0.5;
            if (ground && ground.material) {
                const causticIntensity = 0.05 + Math.sin(causticsTime * 2) * 0.02;
                ground.material.emissive = new THREE.Color(0x4db8d8);
                ground.material.emissiveIntensity = causticIntensity;
            }

            // Animate god rays
            godRays.forEach((ray, i) => {
                ray.position.x += Math.sin(time * 0.5 + ray.userData.offsetX) * 0.002;
                ray.position.z += Math.cos(time * 0.5 + ray.userData.offsetZ) * 0.002;
                ray.material.opacity = 0.1 + Math.sin(time * 0.8 + i) * 0.05;
            });

            // Animate bubbles with variety
            bubbles.forEach(bubble => {
                bubble.position.y += bubble.userData.speed * delta;
                bubble.position.x += Math.sin(time * bubble.userData.wobbleSpeed + bubble.userData.wobble) * 0.01;

                // Reset when reaching top
                if (bubble.position.y > 2.8) {
                    bubble.position.y = 0;
                    bubble.position.x = Math.random() * 5 - 2.5;
                    bubble.position.z = Math.random() * 3 - 1.5;
                }
            });

            // Animate seaweed with bioluminescence pulse
            seaweeds.forEach(seaweed => {
                seaweed.rotation.z = Math.sin(time * seaweed.userData.swaySpeed) * seaweed.userData.baseRotation;

                if (seaweed.userData.glowing) {
                    seaweed.material.emissiveIntensity = 0.2 + Math.sin(time * 2) * 0.1;
                }
            });

            // Animate fish swimming in circles
            fish.forEach((fishGroup, i) => {
                // Circular motion
                fishGroup.userData.angle += fishGroup.userData.speed * delta;
                const x = Math.cos(fishGroup.userData.angle) * fishGroup.userData.radius;
                const z = Math.sin(fishGroup.userData.angle) * fishGroup.userData.radius;

                // Vertical bobbing
                const y = 0.5 + Math.sin(time * fishGroup.userData.verticalSpeed + fishGroup.userData.verticalOffset) * 0.3;

                fishGroup.position.set(x, y, z);

                // Face direction of movement
                fishGroup.rotation.y = fishGroup.userData.angle + Math.PI / 2;

                // Tail wave
                if (fishGroup.children[1]) {
                    fishGroup.children[1].rotation.y = Math.sin(time * 8 + i) * 0.3;
                }
            });

            // Animate floating particles
            particles.forEach(particle => {
                particle.position.x += particle.userData.driftX;
                particle.position.y += particle.userData.driftY;
                particle.position.z += particle.userData.driftZ;

                // Reset if out of bounds
                if (Math.abs(particle.position.x) > 3 ||
                    particle.position.y < 0 || particle.position.y > 3 ||
                    Math.abs(particle.position.z) > 2) {
                    particle.position.set(
                        (Math.random() - 0.5) * 6,
                        Math.random() * 3,
                        (Math.random() - 0.5) * 4
                    );
                }
            });

            // Continuous swimming animation - turtle swims across screen and loops
            if (turtle) {
                turtle.position.x += turtleSwimSpeed * delta;

                // Loop back when turtle swims off right side
                if (turtle.position.x > 3) {
                    turtle.position.x = -3;
                    console.log('Turtle looped back to start');
                }
            }

            // Update animation mixer
            if (mixer) {
                mixer.update(delta);

            }
            // Render the scene
            renderer.render(scene, camera);
        }

        // Handle window resize
        function onWindowResize() {
            if (!container || !camera || !renderer) return;

            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
        }

        // Cleanup function
        function cleanup() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }

            if (renderer) {
                renderer.dispose();
                if (container && renderer.domElement) {
                    container.removeChild(renderer.domElement);
                }
            }

            if (scene) {
                scene.traverse(object => {
                    if (object.geometry) {
                        object.geometry.dispose();
                    }
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                });
            }

            console.log('Turtle animation cleaned up');
        }

        // Start initialization
        init();

        // Cleanup on page unload
        window.addEventListener('beforeunload', cleanup);
    }

    // Check WebGL availability
    function isWebGLAvailable() {
        try {
            const canvas = document.createElement('canvas');
            return !!(window.WebGLRenderingContext &&
                (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
        } catch (e) {
            return false;
        }
    }

    // Fallback to static image
    function showFallbackImage() {
        const container = document.getElementById('turtle-hero-canvas');
        if (!container) return;

        container.innerHTML = '<img src="' + htbData.themeUrl + '/assets/turtle-logo-transparent.png" ' +
            'alt="Happy Turtle Logo" ' +
            'style="width: 100%; height: 100%; object-fit: contain; padding: 2rem;" />';

        console.log('Showing fallback image');
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initTurtleAnimation);
    } else {
        initTurtleAnimation();
    }

})();
